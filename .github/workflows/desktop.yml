name: "Create Release Desktop Assets"

on:
  push:
    tags:
      - "desktop-*"
  workflow_dispatch: # å…è¨±æ‰‹å‹•è§¸ç™¼
    inputs:
      tag_override: # æ‰‹å‹•è§¸ç™¼æ™‚å¯é¸çš„ tag è¼¸å…¥
        description: 'æ‰‹å‹•æŒ‡å®šä¸€å€‹ç‰ˆæœ¬è™Ÿ/tag (ä¾‹å¦‚ desktop-staging-0.1.0)ã€‚å¦‚æžœç‚ºç©ºï¼Œå°‡è‡ªå‹•ç”Ÿæˆä¸€å€‹æ¸¬è©¦ç‰ˆtagã€‚'
        required: false
        type: string

jobs:
  Build-macos:
    name: Build macOS App (Universal)
    runs-on: macos-latest
    environment: desktop-release
    env:
      APP_NAME: Scone
      # ç°½åç›¸é—œ
      MACOS_CERT_BASE64_FROM_SECRET: ${{ secrets.APP_STORE_CONNECT_MACOS_DEVELOPER_ID_CERTIFICATE_BASE64 }}
      MACOS_CERT_PWD_FROM_SECRET: ${{ secrets.APP_STORE_CONNECT_MACOS_DEVELOPER_ID_CERTIFICATE_PASSWORD }}
      # å…¬è­‰ç›¸é—œ
      APPLE_ID_SECRET: ${{ secrets.APPLE_ID }}
      APPLE_PASSWORD_SECRET: ${{ secrets.APPLE_PASSWORD }}
      APPLE_TEAM_ID_SECRET: ${{ secrets.APP_STORE_CONNECT_TEAM_ID }}
    outputs:
      full_tag_name: ${{ steps.version_context.outputs.full_tag_name_output }}
      is_staging_build: ${{ steps.version_context.outputs.is_staging_build_output }}
      display_version: ${{ steps.version_context.outputs.display_version_output }}
    steps:
      - name: Determine Version, Staging Context, and Display Version
        id: version_context
        run: |
          TARGET_TAG=""
          IS_STAGING=false
          VERSION_FOR_DISPLAY=""

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ -n "${{ github.event.inputs.tag_override }}" ]]; then
              TARGET_TAG="${{ github.event.inputs.tag_override }}"
            else
              TARGET_TAG="desktop-staging-manual-${{ github.run_id }}"
            fi
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            TARGET_TAG="${{ github.ref_name }}"
          else
            echo "::error ::Unsupported event: ${{ github.event_name }}"
            exit 1
          fi

          echo "Processing Tag: $TARGET_TAG"

          if [[ "$TARGET_TAG" == desktop-staging-* ]]; then
            IS_STAGING=true
            VERSION_FOR_DISPLAY="${TARGET_TAG#desktop-}" # e.g., staging-0.1.0-id
          elif [[ "$TARGET_TAG" == desktop-* ]]; then
            IS_STAGING=false
            VERSION_FOR_DISPLAY="${TARGET_TAG#desktop-}" # e.g., 0.1.0
          else
            echo "::warning ::Tag '$TARGET_TAG' does not start with 'desktop-'. This is unexpected."
            IS_STAGING=true
            VERSION_FOR_DISPLAY="$TARGET_TAG"
          fi

          echo "Full Tag Name: $TARGET_TAG"
          echo "Is Staging Build: $IS_STAGING"
          echo "Display Version: $VERSION_FOR_DISPLAY"

          # è¨­ç½®ç’°å¢ƒè®Šæ•¸ (ä½¿ç”¨ D_ å‰ç¶´)
          echo "D_TAG_VERSION_ENV=${TARGET_TAG}" >> $GITHUB_ENV
          echo "D_IS_STAGING_BUILD_ENV=${IS_STAGING}" >> $GITHUB_ENV
          echo "D_DISPLAY_VERSION_ENV=${VERSION_FOR_DISPLAY}" >> $GITHUB_ENV

          echo "full_tag_name_output=${TARGET_TAG}" >> $GITHUB_OUTPUT
          echo "is_staging_build_output=${IS_STAGING}" >> $GITHUB_OUTPUT
          echo "display_version_output=${VERSION_FOR_DISPLAY}" >> $GITHUB_OUTPUT

      - name: fetch repo source
        uses: actions/checkout@v4
        with:
          repository: "Yvictor/scone"
          token: ${{ secrets.SCONE_GITHUB_TOKEN }}
          ref: ${{ env.D_IS_STAGING_BUILD_ENV == 'true' && 'staging' || 'master' }}


      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'pnpm'

      - name: Install Dependencies using pnpm
        run: pnpm install --frozen-lockfile

      - name: Run Repair Script for solclientjs types
        run: pnpm repair

      - name: Create .env file for vite build
        run: |
          echo "${{ secrets.ENV_FILE }}" > .env

      - name: Import Certificate and Set Signing Identity
        id: import_and_set_identity
        if: env.MACOS_CERT_BASE64_FROM_SECRET != '' && env.MACOS_CERT_PWD_FROM_SECRET != ''
        env:
          KEYCHAIN_TEMP_PASSWORD: "temp_ci_keychain_pwd"
        run: |
          echo "Importing Apple Developer ID Certificate..."
          echo "${{ env.MACOS_CERT_BASE64_FROM_SECRET }}" | base64 --decode > certificate.p12
          security create-keychain -p "${{ env.KEYCHAIN_TEMP_PASSWORD }}" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "${{ env.KEYCHAIN_TEMP_PASSWORD }}" build.keychain

          # è¨­å®š keychain è¶…æ™‚ç‚º 6 å°æ™‚ï¼Œé˜²æ­¢è‡ªå‹•éŽ–å®š
          security set-keychain-settings -t 21600 -l build.keychain

          # åŒ¯å…¥æ†‘è­‰æ™‚åŒæ™‚æŽˆæ¬Š codesign å’Œ security å·¥å…·
          security import certificate.p12 -k build.keychain -P "${{ env.MACOS_CERT_PWD_FROM_SECRET }}" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "${{ env.KEYCHAIN_TEMP_PASSWORD }}" build.keychain

          # é©—è­‰ keychain å·²è§£éŽ–
          security show-keychain-info build.keychain

          rm certificate.p12

          echo "Verifying certificate and extracting signing identity..."
          CERT_INFO=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -n 1)
          if [ -z "$CERT_INFO" ]; then
            echo "::error ::Developer ID Application certificate not found in keychain."
            security find-identity -v -p codesigning build.keychain
            exit 1
          fi
          CERT_ID=$(echo "$CERT_INFO" | awk -F'"' '{print $2}')
          echo "Found signing identity: $CERT_ID"
          echo "apple_signing_identity_output=$CERT_ID" >> $GITHUB_OUTPUT
          echo "Certificate imported and identity set successfully."

      - name: Setup Rust Environment
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Add Rust targets for Universal macOS build
        run: |
          rustup target add x86_64-apple-darwin
          rustup target add aarch64-apple-darwin

      - name: Update Cargo.toml version for staging
        if: ${{ env.D_IS_STAGING_BUILD_ENV == 'true' }}
        run: |
          # å¾žç’°å¢ƒè®Šæ•¸å–å¾— display version (æ ¼å¼: staging-0.5.9-commit_sha)
          DISPLAY_VERSION="${{ env.D_DISPLAY_VERSION_ENV }}"
          echo "DEBUG: Original DISPLAY_VERSION: $DISPLAY_VERSION"
          
          # æå–åŸºç¤Žç‰ˆæœ¬è™Ÿå’Œ commit hash
          if [[ "$DISPLAY_VERSION" == staging-* ]]; then
            # ç§»é™¤ staging- å‰ç¶´
            VERSION_WITHOUT_PREFIX="${DISPLAY_VERSION#staging-}"
            # æå–ç‰ˆæœ¬è™Ÿ (0.5.9)
            BASE_VERSION=$(echo "$VERSION_WITHOUT_PREFIX" | cut -d'-' -f1)
            # æå– commit hash (å¦‚æžœæœ‰çš„è©±)
            COMMIT_HASH=$(echo "$VERSION_WITHOUT_PREFIX" | cut -s -d'-' -f2-)
          else
            echo "ERROR: Unexpected DISPLAY_VERSION format: $DISPLAY_VERSION"
            exit 1
          fi
          
          echo "DEBUG: BASE_VERSION: $BASE_VERSION, COMMIT_HASH: $COMMIT_HASH"
          
          # ç”Ÿæˆç°¡åŒ–çš„ semver ç‰ˆæœ¬è™Ÿï¼Œç¬¦åˆ MSI é™åˆ¶
          # æ ¼å¼: 0.5.9-123 
          RUN_NUMBER=${{ github.run_number }}
          STAGING_VERSION="${BASE_VERSION}-${RUN_NUMBER}"
          
          echo "DEBUG: Generated staging version: $STAGING_VERSION"
          
          # æ›´æ–° Cargo.toml ç‰ˆæœ¬è™Ÿ
          sed -i '' "s/^version = .*/version = \"$STAGING_VERSION\"/" src-tauri/Cargo.toml
          echo "Updated Cargo.toml version to: $STAGING_VERSION"
          
          # ç‚º staging è¨­å®šæª”æ¡ˆå‘½åç”¨çš„ç‰ˆæœ¬è™Ÿ
          FILE_VERSION="staging-${BASE_VERSION}-${{ github.run_number }}"
          echo "D_FILE_VERSION_ENV=${FILE_VERSION}" >> $GITHUB_ENV
          # ä¿å­˜åŽŸå§‹ commit SHA ä¾› Release Notes ä½¿ç”¨
          if [ -n "$COMMIT_HASH" ]; then
            echo "D_COMMIT_SHA_ENV=${COMMIT_HASH}" >> $GITHUB_ENV
          fi

      - name: Build macOS Universal App
        run: |
          if [[ "${{ env.D_IS_STAGING_BUILD_ENV }}" == "true" || "${{ env.D_IS_STAGING_BUILD_ENV }}" == "True" ]]; then
            # Staging build: è·³éŽ sync-version ä»¥ä¿ç•™æˆ‘å€‘çš„ staging ç‰ˆæœ¬è™Ÿ
            pnpm tauri build --target universal-apple-darwin --verbose
          else
            # Release build: æ­£å¸¸åŸ·è¡ŒåŒ…å« sync-version çš„å‘½ä»¤
            pnpm build:mac
          fi
        env:
          # å¦‚æžœæ˜¯ staging buildï¼ŒVITE_ENV ç‚º stagingï¼Œå¦å‰‡ç‚º production
          VITE_ENV: ${{ env.D_IS_STAGING_BUILD_ENV == 'true' && 'staging' || 'production' }}
          # åœç”¨ä¸¦è¡Œç°½ç½²ä»¥é¿å…ç«¶çˆ­æ¢ä»¶
          TAURI_APPLE_SIGNING_PARALLEL: "false"
          APPLE_SIGNING_IDENTITY: ${{ steps.import_and_set_identity.outputs.apple_signing_identity_output }}
          APPLE_ID: ${{ env.APPLE_ID_SECRET }}
          APPLE_PASSWORD: ${{ env.APPLE_PASSWORD_SECRET }}
          APPLE_TEAM_ID: ${{ env.APPLE_TEAM_ID_SECRET }}
          # æ–°å¢žï¼šTauri æ›´æ–°ç°½å
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}

      - name: Package macOS Artifacts
        id: package_macos # MODIFIED: Added id for output referencing
        run: |
          CONFIG_APP_NAME_RAW=$(jq -r '.package.productName // .package.name // env.APP_NAME' src-tauri/tauri.conf.json)
          SANITIZED_APP_NAME=$(echo "$CONFIG_APP_NAME_RAW" | sed 's/ /-/g')

          echo "DEBUG: SANITIZED_APP_NAME='${SANITIZED_APP_NAME}'"
          echo "DEBUG: D_DISPLAY_VERSION_ENV='${{ env.D_DISPLAY_VERSION_ENV }}'"

          APP_DIR_NAME="${SANITIZED_APP_NAME}.app"
          APP_DIR_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${APP_DIR_NAME}"

          # List files in bundle directory for debugging
          echo "DEBUG: Listing contents of src-tauri/target/universal-apple-darwin/release/bundle/macos/"
          ls -l "src-tauri/target/universal-apple-darwin/release/bundle/macos/"
          echo "DEBUG: Listing contents of src-tauri/target/universal-apple-darwin/release/bundle/dmg/"
          ls -l "src-tauri/target/universal-apple-darwin/release/bundle/dmg/"

          # Find DMG file
          DMG_FILE_PATTERN="src-tauri/target/universal-apple-darwin/release/bundle/dmg/${SANITIZED_APP_NAME}_*universal.dmg"
          DMG_FILE_FOUND=$(ls $DMG_FILE_PATTERN 2>/dev/null | head -n 1)

          # Find Tauri-generated updater files
          UPDATER_ARCHIVE_PATTERN="src-tauri/target/universal-apple-darwin/release/bundle/macos/${SANITIZED_APP_NAME}.app.tar.gz"
          UPDATER_SIG_PATTERN="src-tauri/target/universal-apple-darwin/release/bundle/macos/${SANITIZED_APP_NAME}.app.tar.gz.sig"

          UPDATER_ARCHIVE_FOUND=$(ls "$UPDATER_ARCHIVE_PATTERN" 2>/dev/null | head -n 1)
          UPDATER_SIG_FOUND=$(ls "$UPDATER_SIG_PATTERN" 2>/dev/null | head -n 1)

          # Validation checks
          if [ -z "$DMG_FILE_FOUND" ]; then
            echo "::error ::DMG file matching pattern '$DMG_FILE_PATTERN' not found."
            exit 1
          fi
          if [ ! -d "$APP_DIR_PATH" ]; then
            echo "::error ::App directory '$APP_DIR_PATH' not found."
            exit 1
          fi
          if [ -z "$UPDATER_ARCHIVE_FOUND" ]; then
            echo "::error ::Tauri updater archive not found at: $UPDATER_ARCHIVE_PATTERN"
            exit 1
          fi
          if [ -z "$UPDATER_SIG_FOUND" ]; then
            echo "::error ::Tauri updater signature not found at: $UPDATER_SIG_PATTERN"
            exit 1
          fi

          # Define final file names
          if [[ -n "${{ env.D_FILE_VERSION_ENV }}" ]]; then
            # Staging: ä½¿ç”¨ç°¡åŒ–ç‰ˆæœ¬è™Ÿ
            FINAL_DMG_BASENAME="${SANITIZED_APP_NAME}_${{ env.D_FILE_VERSION_ENV }}_universal.dmg"
            FINAL_UPDATER_BASENAME="${SANITIZED_APP_NAME}_${{ env.D_FILE_VERSION_ENV }}_universal.app.tar.gz"
            FINAL_UPDATER_SIG_BASENAME="${SANITIZED_APP_NAME}_${{ env.D_FILE_VERSION_ENV }}_universal.app.tar.gz.sig"
          else
            # Release: ä¿æŒåŽŸé‚è¼¯
            FINAL_DMG_BASENAME="${SANITIZED_APP_NAME}_${{ env.D_DISPLAY_VERSION_ENV }}_universal.dmg"
            FINAL_UPDATER_BASENAME="${SANITIZED_APP_NAME}_${{ env.D_DISPLAY_VERSION_ENV }}_universal.app.tar.gz"
            FINAL_UPDATER_SIG_BASENAME="${SANITIZED_APP_NAME}_${{ env.D_DISPLAY_VERSION_ENV }}_universal.app.tar.gz.sig"
          fi

          # Move files to workspace
          echo "Moving $DMG_FILE_FOUND to $FINAL_DMG_BASENAME"
          mv "$DMG_FILE_FOUND" "$FINAL_DMG_BASENAME"

          echo "Moving $UPDATER_ARCHIVE_FOUND to $FINAL_UPDATER_BASENAME"
          mv "$UPDATER_ARCHIVE_FOUND" "$FINAL_UPDATER_BASENAME"

          echo "Moving $UPDATER_SIG_FOUND to $FINAL_UPDATER_SIG_BASENAME"
          mv "$UPDATER_SIG_FOUND" "$FINAL_UPDATER_SIG_BASENAME"

          echo "DEBUG: Workspace files after packaging:"
          ls -l

          # Output variables for next steps
          echo "dmg_name_output=${FINAL_DMG_BASENAME}" >> $GITHUB_OUTPUT
          echo "updater_archive_output=${FINAL_UPDATER_BASENAME}" >> $GITHUB_OUTPUT
          echo "updater_sig_output=${FINAL_UPDATER_SIG_BASENAME}" >> $GITHUB_OUTPUT
          echo "commit_sha_output=${{ env.D_COMMIT_SHA_ENV }}" >> $GITHUB_OUTPUT

      - name: Upload macOS Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-build
          path: |
            ${{ steps.package_macos.outputs.dmg_name_output }}
            ${{ steps.package_macos.outputs.updater_archive_output }}
            ${{ steps.package_macos.outputs.updater_sig_output }}

  Build-windows:
    name: Build Windows App (x64)
    runs-on: windows-latest
    environment: desktop-release
    env:
      APP_NAME: Scone
    outputs:
      full_tag_name_output: ${{ steps.version_context.outputs.full_tag_name_output }}
      is_staging_build_output: ${{ steps.version_context.outputs.is_staging_build_output }}
      display_version_output: ${{ steps.version_context.outputs.display_version_output }}
    steps:
      - name: Determine Version and Staging Context
        id: version_context
        shell: pwsh
        run: |
          $TARGET_TAG = ""
          $IS_STAGING = $false
          $VERSION_FOR_DISPLAY = ""

          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            if (-not [string]::IsNullOrEmpty("${{ github.event.inputs.tag_override }}")) {
              $TARGET_TAG = "${{ github.event.inputs.tag_override }}"
            } else {
              $TARGET_TAG = "desktop-staging-manual-${{ github.run_id }}"
            }
          } elseif ("${{ github.event_name }}" -eq "push") {
            $TARGET_TAG = "${{ github.ref_name }}"
          } else {
            Write-Error "Unsupported event: ${{ github.event_name }}"
            exit 1
          }

          Write-Host "Processing Tag (Windows): $TARGET_TAG"
          if ($TARGET_TAG -like "desktop-staging-*") {
            $IS_STAGING = $true
            $VERSION_FOR_DISPLAY = $TARGET_TAG.Substring("desktop-".Length)
          } elseif ($TARGET_TAG -like "desktop-*") {
            $IS_STAGING = $false
            $VERSION_FOR_DISPLAY = $TARGET_TAG.Substring("desktop-".Length)
          } else {
            Write-Warning "Tag '$TARGET_TAG' does not start with 'desktop-'. This is unexpected."
            $IS_STAGING = $true # Defaulting to staging for unexpected tags might need review
            $VERSION_FOR_DISPLAY = $TARGET_TAG
          }

          Write-Host "Full Tag Name (Windows): $TARGET_TAG"
          Write-Host "Is Staging Build (Windows): $IS_STAGING"
          Write-Host "Display Version (Windows): $VERSION_FOR_DISPLAY"

          # è¨­ç½®ç’°å¢ƒè®Šæ•¸ (ä½¿ç”¨ D_ å‰ç¶´)
          "D_TAG_VERSION_ENV=$TARGET_TAG" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          # PowerShell boolean to string is 'True' or 'False', ensure this is handled consistently if read by bash
          "D_IS_STAGING_BUILD_ENV=$($IS_STAGING.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "D_DISPLAY_VERSION_ENV=$VERSION_FOR_DISPLAY" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          "full_tag_name_output=$TARGET_TAG" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "is_staging_build_output=$($IS_STAGING.ToString().ToLower())" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "display_version_output=$VERSION_FOR_DISPLAY" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: fetch repo source
        uses: actions/checkout@v4
        with:
          repository: "Yvictor/scone"
          token: ${{ secrets.SCONE_GITHUB_TOKEN }}
          ref: ${{ env.D_IS_STAGING_BUILD_ENV == 'True' && 'staging' || 'master' }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'pnpm'

      - name: Install Dependencies using pnpm
        run: pnpm install --frozen-lockfile

      - name: Run Repair Script for solclientjs types
        run: pnpm repair

      - name: Create .env file for vite build
        run: |
          echo "${{ secrets.ENV_FILE }}" > .env

      - name: Setup Rust Environment
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          target: x86_64-pc-windows-msvc

      - name: Update Cargo.toml version for staging
        if: ${{ env.D_IS_STAGING_BUILD_ENV == 'True' }}
        shell: pwsh
        run: |
          # å¾žç’°å¢ƒè®Šæ•¸å–å¾— display version (æ ¼å¼: staging-0.5.9-commit_sha)
          $DISPLAY_VERSION = "${{ env.D_DISPLAY_VERSION_ENV }}"
          Write-Host "DEBUG: Original DISPLAY_VERSION: $DISPLAY_VERSION"
          
          # æå–åŸºç¤Žç‰ˆæœ¬è™Ÿå’Œ commit hash
          if ($DISPLAY_VERSION -like "staging-*") {
            # ç§»é™¤ staging- å‰ç¶´
            $VERSION_WITHOUT_PREFIX = $DISPLAY_VERSION.Substring("staging-".Length)
            # åˆ†å‰²ç‰ˆæœ¬è™Ÿå’Œ commit hash
            $parts = $VERSION_WITHOUT_PREFIX -split '-', 2
            $BASE_VERSION = $parts[0]
            if ($parts.Length -gt 1) {
              $COMMIT_PART = $parts[1]
            } else {
              $COMMIT_PART = ""
            }
          } else {
            Write-Error "ERROR: Unexpected DISPLAY_VERSION format: $DISPLAY_VERSION"
            exit 1
          }
          
          Write-Host "DEBUG: BASE_VERSION: $BASE_VERSION, COMMIT_PART: $COMMIT_PART"
          
          # ç”Ÿæˆç°¡åŒ–çš„ semver ç‰ˆæœ¬è™Ÿï¼Œç¬¦åˆ MSI é™åˆ¶
          # æ ¼å¼: 0.5.9-123
          $RUN_NUMBER = "${{ github.run_number }}"
          $STAGING_VERSION = "$BASE_VERSION-$RUN_NUMBER"
          
          Write-Host "DEBUG: Generated staging version: $STAGING_VERSION"
          
          # æ›´æ–° Cargo.toml ç‰ˆæœ¬è™Ÿï¼ˆåªæ›´æ–° package versionï¼Œä¸å½±éŸ¿ rust-versionï¼‰
          $cargoContent = Get-Content "src-tauri\Cargo.toml" -Raw
          # ä½¿ç”¨æ›´ç²¾ç¢ºçš„æ­£å‰‡è¡¨é”å¼ï¼ŒåªåŒ¹é… [package] å€å¡Šä¸‹çš„ version
          $cargoContent = $cargoContent -replace '(?m)^version = "[^"]*"', "version = `"$STAGING_VERSION`""
          Set-Content "src-tauri\Cargo.toml" -Value $cargoContent -NoNewline
          Write-Host "Updated Cargo.toml version to: $STAGING_VERSION"
          
          # ç‚º staging è¨­å®šæª”æ¡ˆå‘½åç”¨çš„ç‰ˆæœ¬è™Ÿ
          $FILE_VERSION = "staging-$BASE_VERSION-${{ github.run_number }}"
          "D_FILE_VERSION_ENV=$FILE_VERSION" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          # ä¿å­˜åŽŸå§‹ commit SHA ä¾› Release Notes ä½¿ç”¨
          if ($COMMIT_PART) {
            "D_COMMIT_SHA_ENV=$COMMIT_PART" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          }

      - name: Build Windows App
        shell: bash
        run: |
          if [[ "${{ env.D_IS_STAGING_BUILD_ENV }}" == "true" || "${{ env.D_IS_STAGING_BUILD_ENV }}" == "True" ]]; then
            # Staging build: è·³éŽ sync-version ä»¥ä¿ç•™æˆ‘å€‘çš„ staging ç‰ˆæœ¬è™Ÿ
            pnpm tauri build --target x86_64-pc-windows-msvc
          else
            # Release build: æ­£å¸¸åŸ·è¡ŒåŒ…å« sync-version çš„å‘½ä»¤
            pnpm build:windows
          fi
        env:
          VITE_ENV: ${{ env.D_IS_STAGING_BUILD_ENV == 'True' && 'staging' || 'production' }}
          # æ–°å¢žï¼šTauri æ›´æ–°ç°½å
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}

      - name: Locate Windows Artifact
        id: locate_msi
        shell: pwsh
        run: |
          $configAppNameRaw = (Get-Content -Raw -Path src-tauri/tauri.conf.json | ConvertFrom-Json).package.productName
          if (-not $configAppNameRaw) { $configAppNameRaw = (Get-Content -Raw -Path src-tauri/tauri.conf.json | ConvertFrom-Json).package.name }
          if (-not $configAppNameRaw) { $configAppNameRaw = "${{ env.APP_NAME }}" }
          $sanitizedAppName = $configAppNameRaw -replace ' ', '-'

          Write-Host "DEBUG: SANITIZED_APP_NAME='${sanitizedAppName}'"
          Write-Host "DEBUG: D_DISPLAY_VERSION_ENV='${{ env.D_DISPLAY_VERSION_ENV }}'"

          $msiSearchPattern = "src-tauri/target/x86_64-pc-windows-msvc/release/bundle/msi/${sanitizedAppName}_*x64_en-US.msi"
          Write-Host "DEBUG: MSI Search Pattern: $msiSearchPattern"

          # List files in the MSI bundle directory for debugging
          Write-Host "DEBUG: Listing contents of src-tauri/target/x86_64-pc-windows-msvc/release/bundle/msi/"
          Get-ChildItem -Path "src-tauri/target/x86_64-pc-windows-msvc/release/bundle/msi/" -ErrorAction SilentlyContinue

          $msiPath = Get-ChildItem -Path $msiSearchPattern | Select-Object -First 1 -ExpandProperty FullName
          if (-not $msiPath) { Write-Error "MSI file not found with pattern: $msiSearchPattern."; exit 1 }

          if ($null -ne $env:D_FILE_VERSION_ENV -and $env:D_FILE_VERSION_ENV -ne "") {
            # Staging: ä½¿ç”¨ç°¡åŒ–ç‰ˆæœ¬è™Ÿ
            $msiName = "${sanitizedAppName}_${{ env.D_FILE_VERSION_ENV }}_x64.msi"
          } else {
            # Release: ä¿æŒåŽŸé‚è¼¯
            $msiName = "${sanitizedAppName}_${{ env.D_DISPLAY_VERSION_ENV }}_x64.msi"
          }
          $originalSigPath = "$msiPath.sig"
          $targetSigName = "$msiName.sig"

          Write-Host "Original MSI Path: $msiPath"
          Write-Host "Target MSI Name for upload: $msiName"
          Write-Host "Original Signature Path: $originalSigPath"
          Write-Host "Target Signature Name: $targetSigName"

          # Copy MSI file
          Copy-Item -Path $msiPath -Destination $msiName -Force
          if (-not (Test-Path $msiName)) { Write-Error "Failed to copy MSI to $msiName"; exit 1}

          # Copy signature file
          if (-not (Test-Path $originalSigPath)) { Write-Error "Signature file not found: $originalSigPath"; exit 1}
          Copy-Item -Path $originalSigPath -Destination $targetSigName -Force
          if (-not (Test-Path $targetSigName)) { Write-Error "Failed to copy signature to $targetSigName"; exit 1}

          # Verify signature content is not empty
          $sigContent = Get-Content -Raw $targetSigName
          if ([string]::IsNullOrWhiteSpace($sigContent)) { Write-Error "Signature file is empty: $targetSigName"; exit 1}
          Write-Host "DEBUG: Signature file size: $((Get-Item $targetSigName).Length) bytes"

          Write-Host "DEBUG: Workspace files after packaging:"
          Get-ChildItem . | Select-Object Name, Length

          "msi_name=$msiName" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "commit_sha_output=${{ env.D_COMMIT_SHA_ENV }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Upload Windows Artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-build
          path: |
            ${{ steps.locate_msi.outputs.msi_name }}
            ${{ steps.locate_msi.outputs.msi_name }}.sig

  create-release:
    name: Create GitHub Release
    needs: [Build-macos, Build-windows]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      CR_FULL_TAG: ${{ needs.Build-macos.outputs.full_tag_name }}
      CR_IS_STAGING: ${{ needs.Build-macos.outputs.is_staging_build }}
      CR_DISPLAY_VERSION: ${{ needs.Build-macos.outputs.display_version }}
    steps:
      - name: Determine Release Name and Prerelease Flag
        id: release_info
        run: |
          FINAL_RELEASE_NAME=""
          MARK_AS_PRERELEASE=false
          CANONICAL_TAG_FOR_RELEASE=""

          CR_IS_STAGING_SHELL="${{ env.CR_IS_STAGING }}"
          CR_DISPLAY_VERSION_SHELL="${{ env.CR_DISPLAY_VERSION }}"
          CR_FULL_TAG_SHELL="${{ env.CR_FULL_TAG }}"

          echo "DEBUG Input: CR_IS_STAGING_SHELL='${CR_IS_STAGING_SHELL}'"
          echo "DEBUG Input: CR_DISPLAY_VERSION_SHELL='${CR_DISPLAY_VERSION_SHELL}'"
          echo "DEBUG Input: CR_FULL_TAG_SHELL='${CR_FULL_TAG_SHELL}'"

          if [[ "$CR_IS_STAGING_SHELL" == "true" ]]; then
            # æ¸¬è©¦ç‰ˆ
            MARK_AS_PRERELEASE=true
            VERSION_PART_AFTER_STAGING_PREFIX="${CR_DISPLAY_VERSION_SHELL#staging-}"
            BASE_VERSION_FOR_TITLE=$(echo "$VERSION_PART_AFTER_STAGING_PREFIX" | cut -d'-' -f1)

            if [[ -z "$BASE_VERSION_FOR_TITLE" ]]; then
              echo "::error ::Could not determine base version for staging from CR_DISPLAY_VERSION_SHELL: ${CR_DISPLAY_VERSION_SHELL}"
              exit 1
            fi

            FINAL_RELEASE_NAME="Desktop-Test $BASE_VERSION_FOR_TITLE"
            CANONICAL_TAG_FOR_RELEASE="desktop-staging-${BASE_VERSION_FOR_TITLE}"
          else
            # æ­£å¼ç‰ˆ
            MARK_AS_PRERELEASE=false # Explicitly false for production
            FINAL_RELEASE_NAME="Desktop $CR_DISPLAY_VERSION_SHELL"
            CANONICAL_TAG_FOR_RELEASE="$CR_FULL_TAG_SHELL"
          fi

          echo "Final Release Name: $FINAL_RELEASE_NAME"
          echo "Is Prerelease: $MARK_AS_PRERELEASE"
          echo "Canonical Tag for Release: $CANONICAL_TAG_FOR_RELEASE"

          echo "release_name_output=${FINAL_RELEASE_NAME}" >> $GITHUB_OUTPUT
          echo "prerelease_output=${MARK_AS_PRERELEASE}" >> $GITHUB_OUTPUT
          echo "canonical_tag_output=${CANONICAL_TAG_FOR_RELEASE}" >> $GITHUB_OUTPUT

      - name: Checkout Yvictor/scone for changelog generation
        uses: actions/checkout@v4
        with:
          repository: "Yvictor/scone"
          token: ${{ secrets.SCONE_GITHUB_TOKEN }}
          fetch-depth: 0
          ref: ${{ env.CR_IS_STAGING == 'true' && 'staging' || env.CR_DISPLAY_VERSION }}
          path: 'changelog_repo'

      - name: Install latest git-cliff
        run: |
          echo "Installing latest stable git-cliff..."
          cargo install git-cliff
          echo "Verifying git-cliff installation..."
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          git-cliff --version
        shell: bash

      - name: Generate Changelog from Yvictor/scone history using git-cliff
        working-directory: ./changelog_repo
        env:
          IS_STAGING_BUILD: ${{ env.CR_IS_STAGING }}
          DISPLAY_VERSION_FOR_LOG: ${{ env.CR_DISPLAY_VERSION }}
        run: |
          echo "Current directory: $(pwd)"
          echo "IS_STAGING_BUILD: ${IS_STAGING_BUILD}"
          echo "DISPLAY_VERSION_FOR_LOG: ${DISPLAY_VERSION_FOR_LOG}"

          > ../RELEASE_NOTES_DESKTOP.md

          CLIFF_COMMAND=""
          GENERATION_TYPE_MESSAGE=""

          if [[ "${IS_STAGING_BUILD}" == "true" ]]; then
            GENERATION_TYPE_MESSAGE="Generating changelog for STAGING: from latest tag to HEAD of 'staging' branch in Yvictor/scone."
            # å°æ–¼æ¸¬è©¦ç‰ˆ (staging åˆ†æ”¯ï¼Œæ²’æœ‰æ–° tag):
            CLIFF_COMMAND="git cliff --unreleased -o ../RELEASE_NOTES_DESKTOP.md"
          else
            GENERATION_TYPE_MESSAGE="Generating changelog for PRODUCTION: for tag '${DISPLAY_VERSION_FOR_LOG}' in Yvictor/scone."
            # å°æ–¼æ­£å¼ç‰ˆ (å·² checkout åˆ°ç‰¹å®š tag):
            CLIFF_COMMAND="git cliff --current -o ../RELEASE_NOTES_DESKTOP.md"
          fi

          echo "${GENERATION_TYPE_MESSAGE}"
          echo "Executing command: ${CLIFF_COMMAND}"

          if ! ${CLIFF_COMMAND}; then
            echo "::warning ::git-cliff command failed. A default message will be used in RELEASE_NOTES_DESKTOP.md."
            echo "Changelog generation using git-cliff failed for this release." > ../RELEASE_NOTES_DESKTOP.md
          fi

          if [ ! -s ../RELEASE_NOTES_DESKTOP.md ]; then
            echo "::warning ::Generated changelog (../RELEASE_NOTES_DESKTOP.md) is empty. Providing a default message."
            echo "No specific changelog details could be generated for this release." > ../RELEASE_NOTES_DESKTOP.md
          fi

          echo "--- Generated Desktop Release Notes (from Yvictor/scone history using git-cliff) ---"
          cat ../RELEASE_NOTES_DESKTOP.md
          echo "-----------------------------------------------------------------------------------"
        shell: bash

      - name: Prepare Build Info for Release Notes
        if: env.CR_IS_STAGING == 'true'
        run: |
          # å¾ž build outputs æˆ– display version ç²å– commit SHA
          COMMIT_SHA="${{ needs.Build-macos.outputs.commit_sha_output }}"
          if [[ -z "$COMMIT_SHA" ]] || [[ "$COMMIT_SHA" == "null" ]]; then
            # å¾ž Windows build å˜—è©¦
            COMMIT_SHA="${{ needs.Build-windows.outputs.commit_sha_output }}"
          fi
          if [[ -z "$COMMIT_SHA" ]] || [[ "$COMMIT_SHA" == "null" ]]; then
            # å¾ž CR_DISPLAY_VERSION æå– (fallback)
            COMMIT_SHA=$(echo "${{ env.CR_DISPLAY_VERSION }}" | sed 's/^staging-[0-9.]*-//')
          fi
          
          # æº–å‚™æ§‹å»ºè³‡è¨Š
          BUILD_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          BASE_VERSION=$(echo "${{ env.CR_DISPLAY_VERSION }}" | sed 's/^staging-//' | cut -d'-' -f1)
          BUILD_VERSION="staging-${BASE_VERSION}-${{ github.run_number }}"
          
          # è¿½åŠ åˆ° Release Notes
          {
            cat RELEASE_NOTES_DESKTOP.md
            echo ""
            echo "---"
            echo "### ðŸ“¦ Build Information"
            echo "- **Version**: ${BUILD_VERSION}"
            echo "- **Commit**: \`${COMMIT_SHA}\`"
            echo "- **Build Time**: ${BUILD_TIME}"
            echo "- **Build Number**: #${{ github.run_number }}"
          } > RELEASE_NOTES_TEMP.md
          mv RELEASE_NOTES_TEMP.md RELEASE_NOTES_DESKTOP.md
          
          echo "Updated Release Notes with build information"
          cat RELEASE_NOTES_DESKTOP.md

      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: List downloaded artifacts
        run: |
          echo "Listing downloaded artifacts in $(pwd)/artifacts/ :"
          ls -lR artifacts/
          echo "--- macOS Build (expected in artifacts/macos-build/): ---"
          ls -l artifacts/macos-build/
          echo "--- Windows Build (expected in artifacts/windows-build/): ---"
          ls -l artifacts/windows-build/
          echo "--- Release Notes file in workspace root: ---"
          ls -l ${{ github.workspace }}/RELEASE_NOTES_DESKTOP.md

      - name: Generate Update Manifest
        run: |
          # Debug: List all artifact files
          echo "DEBUG: Listing macOS build artifacts:"
          ls -la artifacts/macos-build/
          echo "DEBUG: Listing Windows build artifacts:"
          ls -la artifacts/windows-build/

          # Get artifact file names - CORRECTED PATHS
          MACOS_UPDATER=$(ls artifacts/macos-build/*.tar.gz | grep -v "\.sig" | head -n 1)
          MACOS_SIG=$(ls artifacts/macos-build/*.tar.gz.sig | head -n 1)
          WINDOWS_MSI=$(ls artifacts/windows-build/*.msi | head -n 1)
          WINDOWS_SIG=$(ls artifacts/windows-build/*.msi.sig | head -n 1)

          # Validation checks
          if [ -z "$MACOS_UPDATER" ]; then
            echo "::error ::macOS updater archive not found in artifacts/macos-build/"
            exit 1
          fi
          if [ -z "$MACOS_SIG" ]; then
            echo "::error ::macOS signature file not found in artifacts/macos-build/"
            exit 1
          fi
          if [ -z "$WINDOWS_MSI" ]; then
            echo "::error ::Windows MSI file not found in artifacts/windows-build/"
            exit 1
          fi
          if [ -z "$WINDOWS_SIG" ]; then
            echo "::error ::Windows signature file not found in artifacts/windows-build/"
            exit 1
          fi

          # Debug: Show found files
          echo "DEBUG: Found files:"
          echo "  macOS Updater: $MACOS_UPDATER"
          echo "  macOS Signature: $MACOS_SIG"
          echo "  Windows MSI: $WINDOWS_MSI"
          echo "  Windows Signature: $WINDOWS_SIG"

          # Read signature contents with validation
          if [ ! -f "$MACOS_SIG" ]; then
            echo "::error ::macOS signature file does not exist: $MACOS_SIG"
            exit 1
          fi
          if [ ! -f "$WINDOWS_SIG" ]; then
            echo "::error ::Windows signature file does not exist: $WINDOWS_SIG"
            exit 1
          fi

          MACOS_SIGNATURE=$(cat "$MACOS_SIG" | tr -d '\n\r')
          WINDOWS_SIGNATURE=$(cat "$WINDOWS_SIG" | tr -d '\n\r')

          # Validate signatures are not empty
          if [ -z "$MACOS_SIGNATURE" ]; then
            echo "::error ::macOS signature is empty"
            exit 1
          fi
          if [ -z "$WINDOWS_SIGNATURE" ]; then
            echo "::error ::Windows signature is empty"
            exit 1
          fi

          echo "DEBUG: Signature lengths:"
          echo "  macOS: ${#MACOS_SIGNATURE} characters"
          echo "  Windows: ${#WINDOWS_SIGNATURE} characters"

          # Generate semver-compatible version number
          SEMVER_VERSION=""
          if [[ "${{ env.CR_IS_STAGING }}" == "true" ]]; then
            # Convert staging-0.5.9-ea4ed8a -> 0.5.9-staging.ea4ed8a
            DISPLAY_VERSION="${{ env.CR_DISPLAY_VERSION }}"
            echo "DEBUG: Original staging version: $DISPLAY_VERSION"
            
            # Extract base version (remove staging- prefix)
            BASE_VERSION=$(echo "$DISPLAY_VERSION" | sed 's/^staging-//' | cut -d'-' -f1)
            
            # Extract commit hash (everything after the first dash following base version)
            COMMIT_HASH=$(echo "$DISPLAY_VERSION" | sed 's/^staging-[0-9.]*//' | sed 's/^-//')
            
            # Create simplified semver version for staging
            # Format: 0.5.9-123 (ensures proper update from staging to release)
            RUN_NUMBER=${{ github.run_number }}
            SEMVER_VERSION="${BASE_VERSION}-${RUN_NUMBER}"
          else
            # For release versions, use as-is
            SEMVER_VERSION="${{ env.CR_DISPLAY_VERSION }}"
          fi
          
          echo "DEBUG: Generated semver version: $SEMVER_VERSION"

          # Create update manifest - NOTE: URLs point to updater files, not installers
          cat > update-manifest.json << EOF
          {
            "version": "$SEMVER_VERSION",
            "notes": "æª¢æŸ¥ Release Notes äº†è§£è©³ç´°æ›´æ–°å…§å®¹",
            "pub_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "platforms": {
              "darwin-universal": {
                "signature": "$MACOS_SIGNATURE",
                "url": "https://github.com/Sinotrade/scone/releases/download/${{ steps.release_info.outputs.canonical_tag_output }}/$(basename "$MACOS_UPDATER")"
              },
              "windows-x86_64": {
                "signature": "$WINDOWS_SIGNATURE",
                "url": "https://github.com/Sinotrade/scone/releases/download/${{ steps.release_info.outputs.canonical_tag_output }}/$(basename "$WINDOWS_MSI")"
              }
            }
          }
          EOF

          echo "Generated update manifest:"
          cat update-manifest.json

      - name: Upload Update Manifest
        uses: actions/upload-artifact@v4
        with:
          name: update-manifest
          path: update-manifest.json

      - name: Clean up old assets from Staging Release
        if: steps.release_info.outputs.prerelease_output == 'true' # Only run for staging/prerelease
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: ${{ steps.release_info.outputs.canonical_tag_output }}
        run: |
          echo "Attempting to clean up all old assets for release tag: $RELEASE_TAG on repo $GITHUB_REPOSITORY"

          if ! gh release view "$RELEASE_TAG" --repo "$GITHUB_REPOSITORY" --json id --jq .id > /dev/null 2>&1 ; then
            echo "Release $RELEASE_TAG does not exist yet on $GITHUB_REPOSITORY. No assets to clean up."
            exit 0 # Successfully exit, as there's nothing to clean
          fi

          echo "Fetching existing assets (.dmg, .msi, .tar.gz, .sig) for release $RELEASE_TAG from $GITHUB_REPOSITORY..."

          ASSET_LIST_FILE=$(mktemp)
          gh release view "$RELEASE_TAG" --repo "$GITHUB_REPOSITORY" --json assets --jq '.assets[] | select(.name | test("(?i)\\.(dmg|msi|tar\\.gz|sig)$")) | .name' > "$ASSET_LIST_FILE"

          if [ ! -s "$ASSET_LIST_FILE" ]; then # Check if file is empty (no assets found)
            echo "No assets found to delete for release $RELEASE_TAG on $GITHUB_REPOSITORY."
          else
            echo "Found assets to delete on $GITHUB_REPOSITORY:"
            cat "$ASSET_LIST_FILE"

            while IFS= read -r ASSET_NAME; do
              if [ -n "$ASSET_NAME" ]; then
                echo "Deleting asset: '$ASSET_NAME' from release $RELEASE_TAG on $GITHUB_REPOSITORY..."
                gh release delete-asset "$RELEASE_TAG" "$ASSET_NAME" --repo "$GITHUB_REPOSITORY" -y
                if [ $? -eq 0 ]; then
                  echo "Successfully deleted '$ASSET_NAME'."
                else
                  echo "::warning ::Failed to delete asset '$ASSET_NAME' or it was already removed."
                fi
              fi
            done < "$ASSET_LIST_FILE"
            echo "Finished cleaning up old assets."
          fi
          rm "$ASSET_LIST_FILE"

      - name: Create/Update GitHub Release on Sinotrade/scone
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: ${{ steps.release_info.outputs.canonical_tag_output }}
          name: ${{ steps.release_info.outputs.release_name_output }}
          body_path: RELEASE_NOTES_DESKTOP.md
          prerelease: ${{ steps.release_info.outputs.prerelease_output }}
          files: |
            artifacts/macos-build/*
            artifacts/windows-build/*
            update-manifest.json

  trigger-web-deployment:
    name: Trigger GitHub Pages Update
    needs: [create-release, Build-macos]
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Web Deployment with Manifests Update
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          event-type: update-manifests
          client-payload: '{"triggered_by": "desktop-release", "tag": "${{ needs.Build-macos.outputs.full_tag_name }}", "is_staging": "${{ needs.Build-macos.outputs.is_staging_build }}"}'
